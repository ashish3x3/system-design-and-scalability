




Operational_transformation
https://en.wikipedia.org/wiki/Operational_transformation

System architecture

Collaboration systems utilizing Operational Transformations typically use replicated document storage, where each client has their own copy of the document; 
clients operate on their local copies in a lock-free, non-blocking manner, and the changes are then propagated to the rest of the clients; this ensures the client high responsiveness in an otherwise high-latency environment such as the Internet. 
When a client receives the changes propagated from another client, it typically transforms the changes before executing them; 
the transformation ensures that application-dependent consistency criteria (invariants) are maintained by all sites. 
This mode of operation results in a system particularly suited for implementing collaboration features, like simultaneous document editing, in a high-latency environment such as the web.




Basics

The basic idea of OT can be illustrated by using a simple text editing scenario as follows. Given a text document with a string "abc" replicated at two collaborating sites; and two concurrent operations:

O1 = Insert[0, "x"] (to insert character "x" at position "0")
O2 = Delete[2, "c"] (to delete the character "c" at position "2")
generated by two users at collaborating sites 1 and 2, respectively. 

Suppose the two operations are executed in the order of O1 and O2 (at site 1). 
After executing O1, the document becomes "xabc". 
To execute O2 after O1, O2 must be transformed against O1 to become: O2' = Delete[3, "c"], whose positional parameter is incremented by one due to the insertion of one character "x" by O1. 
Executing O2' on "xabc" deletes the correct character "c" and the document becomes "xab". 
However, if O2 is executed without transformation, it incorrectly deletes character "b" rather than "c". 
The basic idea of OT is to transform (or adjust) the parameters of an editing operation according to the effects of previously executed concurrent operations so that the transformed operation can achieve the correct effect and maintain document consistency.





Operational Transformation or How Google Docs Works
http://blog.gainlo.co/index.php/2016/03/22/system-design-interview-question-how-to-design-google-docs/

https://www.youtube.com/watch?v=u2_yccaHbQk
https://www.youtube.com/watch?v=NSTZ4mIv_wk
https://www.youtube.com/watch?v=RO59n7rag2U
https://www.quora.com/How-is-collaborative-document-editing-implemented-in-Google-Docs-How-are-infinite-undo-redo-implemented-separately-for-each-user-What-tasks-are-offloaded-to-the-client-and-which-are-done-at-the-server-itself
http://www.laktek.com/2010/05/25/real-time-collaborative-editing-with-websockets-node-js-redis/



we can have series of opeaion which execute some functions like 

Operation A:
insertCharacter("hello")
retain(1)   ... here reatin(1) means move one step forward
insertCharacters("world")

Now output = hello world

Opearationn B:
deleteCharacters(1) .... index start at 1 here
insertCharacters("H")
retain(5)... reatin(5) means move 5 step forward

deleteCharacters(1)
insertCharacters("W")
retain(5) reatin(5) means move 5 step forward


Now output = Hello World

Composition 
Opearion A * Opeartion B = Hello World



Rules of Composition
need to be in ordr
must go through same index
not all opeartion can be combined .. we will not talk abiut it today


Google Formula
trnaform : xform(a,b) = (a`, b`), where b` * a =(concruent) a` * b 


define relationship between the two operations:
Insert/Insert
dekete/deelte
Insert/delete
delete/insert



design strategy diagram
C:\Users\ASHISH KUMAR\Google Drive\Laptop Saved\STUDIES\GOOGLE PREP PROGRAMMING\Scalability\Pictures used in documents\operational_trnasformation_strategy


Design strategy
clinet   --- > Server central Hub --- >server copy of document
						|^			---> operational compression --- > transform function(s) ------
						|																		  | loops back to server from trasform func
						---------	------------------------------------------------------ <----- |



Two factors to keep in mind in concurrent ediring:
1. convergence ... in the end both sates should be equal.
2. preservation of intention .. if I want to append aowrrd between A and B and becaus of concurrent editing, it came between X and C, then thats ot preservation of intention..


string  = ABC

Insert(c,X)                            Delete(1)

AXBC									BC

delete(1)								delete(1)
Insert(2,X)								insert(2,X)
BC 										BC
BXC										BXC

now above solevd convegence problem by maintanig a order of which came frst by using vector clock..here delete(1) heppdn before indert(2,X)
but preservation of intention is still ot covered.. as opearation A wanted to indsert Xbetween a and b

To accomplish that, we will do the following.
we will run the composition in both user and if index of first is < index of seconf opeation we wjave no problem, u tin index of first > index of 2nd then after performing frst operation, second index will go wrong as one character from its front has been deleted,etc
In such case we decrese th index of secon operation by  (index of big - index of small) index



insert (2,X)          delete(1)
AXBC					BC
						insert(2,X).delete(1) ...so index 2 > 1, then decrese insert(1,X)
						insert(1,X)
						XBC

delete(1).insert(2,X)  index 1 < 2, so no chage
delete(1)
XBC

Now we have maintianed bith the property..convergnce ad intention preservation



What WOOT(without operational tranfroation)
they provide partial orser..like insert(a,x,b)..inseert x between a and b

whe thye say delte, it only marks the character and hidden..

so even afterdelte(1) from ABC senconf insert between A dn B will still hold bcz A is hidden but present in BC..so X getsinserte making it XBC thus sync wit other op resut


Data structure to hold each character ( ID,isVIsible, content, prevId, nextId )

nextId is equal to special char in case of last char..
Id is the special Id geiven to each character.. mix and match of timestamp and counterId
precvId = previd of the character
content = actual contant character
isvisble = counter -1,0,1 ..-1 invisble, 0 vsible.. undo = current vql - 1 , redo = curreval + 1



http://www.laktek.com/2010/05/25/real-time-collaborative-editing-with-websockets-node-js-redis/
Common Feaures:
ability watch who else is editing the file, view others edits, chat with the other collaborators and replay how the edits were done


Taking Diffs and Applying Patches

In case if you wonder, this is how the real-time collaboration is done:

when one user makes a change; a diff will be created for his change and sent to server.
Then the server posts this diff to other connected collaborators of the pad.
When a user receives a diff, his content will be patched with the update.


So both taking diffs and applying patches gets executed on the client side. Handling these two actions on browser was made trivial thanks to this comprehensive library(https://code.google.com/archive/p/google-diff-match-patch/) written by Neil Fraser.

Diff:
Compare two blocks of plain text and efficiently return a list of differences.

Match:
Given a search string, find its best fuzzy match in a block of plain text. Weighted for both accuracy and location.

Patch:
Apply a list of patches onto plain text. Use best-effort to apply patch even when the underlying text doesn't match.

However, on some occasions these two actions needs to be executed concurrently. We know by default client-side scripts get executed in a single thread. This makes execution synchronous and slow. As a solution to this I tried using the Web Workers API in HTML5 (this is implemented in WebKit & Mozilla). Separate worker scripts were used for taking diffs and applying patches. The jobs were passed on to this worker scripts from the main script and the results were passed back to main script after execution was complete. Not only this made the things fast, but also more organized.



Node.js for Backend Servers
 brings the JavaScript's familiar event-driven model to server, making things very flexible. On the other hand, Google's V8 JavaScript engine turned out to be really fast. I decided to ditch the Ruby based implementation and fully use Node.js for the backend system.

Backend is consist of two parts. One for serving normal HTTP requests and other for web socket requests. For serving HTTP requests, I used Node.js based web framework called Express. 


Web socket server was implemented based on the recently written web socket server module for Node.js 




Message delivery with Redis Pub/Sub

On each pad, there are different types of messages that users send on different events. These messages needs to be propagated correctly to other users.

Mainly following messages needs to be sent:

When a user joins a pad
When a user leaves a pad
When a user sends a diff
When a user sends a chat message


For handling the message delivery, I used Redis' newly introduced pub/sub implementation. Every time a user is connected (i.e. visits a pad) there would be two redis client instances initiated for him. One client is used for publishing his messages, while other will be used to listen to incoming messages from subscribed channels.

Redis as a persistent store

Not only for message handling, I also use Redis as the persistent data store of the application. As a key-value store Redis can provide fast in-memory data access. Also, it will write data to disk on a given interval (also, there is a much safer Append only mode, which will write every change to disk). This mechanism is invaluable for this sort of application where both fast access and integrity of the data matters.

Another advantage of using Redis is the support for different data types. In Realie, the snapshots are stored as strings. The diffs, chat messages and users for a pad are stored as lists.

There is a well written redis client for Node.js which makes the above tasks really simple.



















































